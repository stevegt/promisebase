# core RFC-1003
## Data Formats

Status: draft

### Overview

XXX

### Example Tree File Format

```
tree
tree/sha256/fc0d850d5930109e3eb3b799f067da93483fb80407e5d9dac56e17455be1dbaa
blob/sha256/a13d00682410383f1003d6428d1028d6feb88f166e1266949bc4cd91725d532a
```


### Preimage Attack Prevention


block1 content: "blob1value"
block1 hash = sha256("blob1value"): 1499559e764b35ac77e76e8886ef237b3649d12014566034198661dc7db77379 

block2 content: "blob2value"
block2 hash = sha256("blob2value"): 48618376a9fcd7ec1147a90520a003d72ffa169b855f0877fd42b722538867f0  -

- right now we're doing this: Hnode = H(             "blob" || H(block1) ||   "blob" || H(block2) )

current (bad) node1 content:
blob/sha256/1499559e764b35ac77e76e8886ef237b3649d12014566034198661dc7db77379
blob/sha256/48618376a9fcd7ec1147a90520a003d72ffa169b855f0877fd42b722538867f0

- guidelines say do this:     Htree = H(   1    || H(  0    ||   block1) || H(  0    ||   block2) )
- so we should be doing this: Htree = H( "tree\n" || H("blob" ||   block1) || H("blob" ||   block2) )

block1 hash = sha256("blob\n" + "blob1value"): a13d00682410383f1003d6428d1028d6feb88f166e1266949bc4cd91725d532a 
block2 hash = sha256("blob\n" + "blob2value"): fc0d850d5930109e3eb3b799f067da93483fb80407e5d9dac56e17455be1dbaa 

- Htree = H( "tree\n" || H("blob\n" ||   "blob1value") || H("blob\n" ||   "blob2value") )

better block1 file content:
blob
blob1value

better block2 file content:
blob
blob2value

better tree1 file content:
tree
sha256/a13d00682410383f1003d6428d1028d6feb88f166e1266949bc4cd91725d532a
sha256/fc0d850d5930109e3eb3b799f067da93483fb80407e5d9dac56e17455be1dbaa

- Htree = d5e256355a3290cf2c25132ecdc271bc74236c2186b35b693a56a3d579a13a4c



### Preimage Attack Example:

block1 file:
the sky is blue because

block2 file:
of light scattering in the upper atmosphere

tree1 file:
570419e731ce93f3dd0735268b7002078ff324c1b992dd342fa099554fadbd5d
b9283e8082c580829a5603b65a6cafc5f09d63b6a6593a094d832e605a5a95ab

tree1 hash:
d47d423d0d59d4209ae5ee25800d2edc0bbf4b83a2493ae8aa6f28018dd6a67a

### About Salt Hiding

We aren't doing it.  Our salts are "blob" and "tree".
Our goal isn't to keep two pieces of data from hashing to the same         
value, as in passwords -- we in fact want identical data to have the      
same hash, for deduplication.  The reason we salt is to not enable  
hash reversing of out-of-band protocols.

https://stackoverflow.com/questions/213380/the-necessity-of-hiding-the-salt-for-a-hash

Passwords get salted to prevent the same password    from two
different users resulting in the same hash.  That's not    exactly
what I mean we should do with data blocks -- we want the    same data
to always result in the same hash.  What I mean    instead is that, if
Mallory finds a hash of the cleartext of    some private data
somewhere, and that data wasn't salted before    hashing, we should
not make it easy for Mallory to use our tool    to fetch that private
data. Making Mallory's attack easy would    break a lot of the modern
world by making one-way hashes    reversible -- I've been worried
about that vulnerability from    the beginning.  We can resist
Mallory's attack by first salting    the private data before hashing
it.  I think that we can prevent    Mallory's attack by simply
prepending the word "blob" on every    block before hashing it, for
instance.
